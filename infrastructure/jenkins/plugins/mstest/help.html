<div>
   <p>
        The MSTest plugin can convert TRX format test reports into JUnit XML format so it can be recorded
        by Hudson.
   </p>

<h2>General Usage</h2>
   <p>To enable the MSTest plugin features you need to set up your build to run MSTest.exe (or VSTest.Console.exe) first. Example:
        <ul><code> "%PROGRAMFILES%\Microsoft Visual Studio 9.0\Common7\IDE\MSTest.exe" /runconfig:MyTestProject\LocalTestRun.testrunconfig /testcontainer:MyTestProject\bin\Release\MyTestProject.dll /resultsfile:TestResults\testResults.trx
       </code></ul>

       and then specify the path to the MSTest TRX file, <code>TestResults/testResults.trx</code> in the above example.
   </p>
   <p>
       When using VSTest.Console.exe, you can't specify the path to the resulting TRX file. Thus, you can specify a pattern like <code>TestResults/*/*.trx</code> (/ or \, either will work).
   </p>
   <p>
        If you use the vstestrunner-plugin, the full path to the TRX file is exposed by an environment variable. So, you can also use an environment variable, 
        like <code>$VSTEST_RESULT_TRX</code> or <code>${VSTEST_RESULT_TRX}</code>.
   </p>
<h2>Test Reporting Options</h2>
   <p>
        Test authors can control how each test appears in Hudson/Jenkins by writing specially formatted text to stdout (the console) at the beginning of the test method.  The following options are available:
        <ul><li>Append text to the test name (useful for identifying individual data-driven test instances)</li>
            <li>Omit a test from Hudson/Jenkins (useful for some data-driven test scenarios)</li>
            <li>Change the test's display name from the name of the test method to an alternate name (useful when reporting results to non-developers)</li>
        </ul>
        In all cases, the specially formatted text must be the first text to appear in the individual test's stdout.
    </p>
  <h3>Appending to a test's display name (naming each data-driven test instance)</h3>
    <p>
       You may want a test to appear in Jenkins with additional text appended to the usual name of the test method.  This is 
       particularly useful for data-driven tests, allowing you to give each individual test case an identifying suffix. To change a test's 
       display name, write the following line as the first text written to stdout during the test's execution:

        <ul><code>test-instance-name:<i>{test instance name}</i>:</code></ul>

       Replace "{test instance name}" with whatever text you want to have appended to the test name in test reports.  For example, if a 
       test method is named <code>MyTestMethod</code>, and the first line of a particular execution of that test method is 
       <code>test-instance-name:Test Case A:</code>, that instance of the test will be displayed in Jenkins as <code>MyTestMethod.Test Case A</code>.  
       Colons are used to delimit the test instance name, so the instance name itself must not contain a colon.
    </p>
    <p>
      This option is particularly useful if you store the test case name as part of each data row in the data source.  You can then refer to 
      the name in the test itself:

        <ul><code>Console.WriteLine(String.Format("test-instance-name:{0}:", data_row("TestCaseName")))</code></ul>

      You could also use the values of the input parameters themselves as the test instance name: 

        <ul><code>Console.WriteLine(String.Format("test-instance-name:{0}, {1}:", data_row("param1"), data_row("param2")))</code></ul>

       Note that if you don't specify a <code>test-instance-name</code>, then data driven tests are automatically given a suffix based on 
       the data row ID (such as "row 3"), similar to what is displayed in Visual Studio.
    </p>
    <p>
       Be aware that TRX files generated by vstest.console.exe differ slightly from those generated by mstest, and these differences 
       affect how data-driven test names appear in test reports.  Specifically, data-driven tests appear with their data
       row number, even if you append a test instance name.  For example, an instance of the test <code>MyTestMethod</code> with the instance
       name <code>Test Case A</code> will be displayed as <code>MyTestMethod.Test Case A</code> if the TRX file was generated by mstest, and
       as <code>MyTestMethod (Data Row 0).Test Case A</code> if the TRX file was generated by vstest.console.exe.
    </p>

  <h3>Omitting a test from the test report</h3>
    <p>
      You may want a test to be removed from the test report.  This is useful in some data-driven test scenarios.  For example, consider a 
      set of input parameters in a data source, each of which will be provided to multiple tests.  Some inputs may not apply to certain tests.
      The testing framework will run each test against every available data row, even if the input doesn't apply to a particular test.  Removing
      irrelevant test cases from the test report is cleaner and gives more accurate statistics.  The syntax to omit a test is similar to other 
      reporting options:

         <ul><code>omit-from-jenkins:true</code></ul>

      Like the other reporting options, this must be the first line of text written to stdout during the execution of the test you want to filter 
      from the test report.
    </p>
<h4>Example</h4>
    <p>
      Here is an example of how this capability might be used.  Consider a data source with the following data:

         <ul><table border="1">
           <thead><tr><th>TestCaseName</th><th>Param1</th><th>ExpectedResult1</th><th>ExpectedResult2</th></tr></thead>
           <tr><td>Case A</td><td>"Input1"</td><td>3.1</td><td>1.7</td></tr>
           <tr><td>Case B</td><td>"Input2"</td><td>0.9</td><td>1.0</td></tr>
           <tr><td>Case C</td><td>"Input3"</td><td>4.2</td><td></td></tr>
         </table></ul>

      In this example, Test1 applies to all 3 data rows, with the expected result specified as ExpectedResult1.  Test2, however, only applies 
      to the first 2 data rows; the test does not apply to Case C, as indicated by the blank ExpectedResult2 for that data row.  The Test2 test 
      method will need to recognize which test cases to ignore, and write reporting instructions accordingly:

       <ul><code><pre>
     [DataSource("blah blah blah")]
     [TestMethod()]
     public void Test2()
     {
        if (testContext.DataRow("ExpectedResult2") == null) {
            Console.WriteLine("omit-from-jenkins:true");
            return;
        }

        Console.WriteLine(String.Format("test-instance-name:{0}:", testContext.DataRow("TestCaseName")));
        // do test logic
        ...
     }  
     </pre></code></ul>
  </p>

  <h3>Renaming a test</h3>
   <p>
       You may want a test to appear in Jenkins with a different name than the name of the test method, possibly to provide a more 
       readable name than the name of the test method.  To change a test's display name, write the following line as the first text 
       written to stdout during the test's execution:

         <ul><code>test-alternate-name:<i>{alternate name}</i>:</code></ul>

       Replace "{alternate name}" with whatever text you want to use as the name of the test in Jenkins reports.  For example, 
       <code>test-alternate-name:My Test:</code> will be displayed in Jenkins as <code>My Test</code>, regardless of the name
       of the test's test method.  Colons are used to delimit the alternate test name, so the alternate name itself must not contain
       a colon.
    </p>
    <p>
       The <code>test-alternate-name</code> option may not be combined with any other reporting option.  If you want to rename a
       test <i>and</i> append a suffix, include the suffix in the name supplied to the <code>test-alternate-name</code> directive.
    </p>

</div>


